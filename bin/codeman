#!/usr/bin/env bash
set -euo pipefail

resolve_source_path() {
  local src="$1"
  while [ -L "$src" ]; do
    local dir
    dir="$(cd -- "$(dirname -- "$src")" && pwd)"
    src="$(readlink "$src")"
    case "$src" in
      /*) ;;
      *) src="$dir/$src" ;;
    esac
  done
  local final_dir
  final_dir="$(cd -- "$(dirname -- "$src")" && pwd)"
  printf '%s/%s\n' "$final_dir" "$(basename -- "$src")"
}

SCRIPT_PATH="$(resolve_source_path "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname -- "$SCRIPT_PATH")"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"
VERSION_FILE="$REPO_ROOT/VERSION"
CONFIG_DIR="${CODEMAN_CONFIG_DIR:-$HOME/.config/codeman}"
CONFIG_FILE="$CONFIG_DIR/config.env"

CODEMAN_NOTIFY_LAST_WAIT=0
CODEMAN_NOTIFY_LAST_COMPLETE=0
CODEMAN_NOTIFY_SUPPRESS=0
CODEMAN_CONFIRM="${CODEMAN_CONFIRM:-1}"
CODEMAN_SAVED_NOTIFY_PREFIX="${CODEMAN_SAVED_NOTIFY_PREFIX:-}"

read_version() {
  if [ -f "$VERSION_FILE" ]; then
    tr -d '[:space:]' < "$VERSION_FILE"
  else
    printf '0.0.0-unknown'
  fi
}

repeat_char() {
  local ch="$1"
  local n="$2"
  local out=""
  local i
  for ((i = 0; i < n; i++)); do
    out+="$ch"
  done
  printf '%s' "$out"
}

color_enabled() {
  # Only emit ANSI when we control a TTY; also honor NO_COLOR and CODEMAN_COLOR=0.
  [ -t 2 ] || return 1
  [ "${TERM:-}" != "dumb" ] || return 1
  [ -z "${NO_COLOR:-}" ] || return 1
  [ "${CODEMAN_COLOR:-1}" != "0" ] || return 1
  return 0
}

ansi_color_for_severity() {
  local severity="$1"
  case "$severity" in
    info) printf '\033[32m' ;;     # green
    warning) printf '\033[33m' ;;  # yellow
    critical) printf '\033[31m' ;; # red
    *) printf '\033[0m' ;;
  esac
}

ansi_reset() {
  printf '\033[0m'
}

print_panel() {
  # Avoid wide emoji inside the panel (they can break border alignment in some terminals).
  local severity="$1"
  local header="$2"
  shift 2

  local tl tr bl br v h sl sr
  case "$severity" in
    info)
      tl="‚ï≠"; tr="‚ïÆ"; bl="‚ï∞"; br="‚ïØ"; v="‚îÇ"; h="‚îÄ"; sl="‚îú"; sr="‚î§"
      ;;
    warning)
      tl="‚îè"; tr="‚îì"; bl="‚îó"; br="‚îõ"; v="‚îÉ"; h="‚îÅ"; sl="‚î£"; sr="‚î´"
      ;;
    critical)
      tl="‚ïî"; tr="‚ïó"; bl="‚ïö"; br="‚ïù"; v="‚ïë"; h="‚ïê"; sl="‚ï†"; sr="‚ï£"
      ;;
    *)
      tl="‚ï≠"; tr="‚ïÆ"; bl="‚ï∞"; br="‚ïØ"; v="‚îÇ"; h="‚îÄ"; sl="‚îú"; sr="‚î§"
      ;;
  esac

  local max="${#header}"
  local line
  for line in "$@"; do
    [ "${#line}" -gt "$max" ] && max="${#line}"
  done

  local bar
  bar="$(repeat_char "$h" $((max + 2)))"

  printf '%s%s%s\n' "$tl" "$bar" "$tr"
  printf '%s %s%s %s\n' "$v" "$header" "$(repeat_char " " $((max - ${#header})))" "$v"
  printf '%s%s%s\n' "$sl" "$bar" "$sr"
  for line in "$@"; do
    if color_enabled && [[ "$line" == [‚úî‚ö†‚úñ]\ * ]]; then
      local icon rest pad
      icon="${line%% *}"
      rest="${line#* }"
      pad="$(repeat_char " " $((max - ${#line})))"
      printf '%s %s%s%s %s%s %s\n' \
        "$v" \
        "$(ansi_color_for_severity "$severity")" "$icon" "$(ansi_reset)" \
        "$rest" "$pad" \
        "$v"
    else
      printf '%s %s%s %s\n' "$v" "$line" "$(repeat_char " " $((max - ${#line})))" "$v"
    fi
  done
  printf '%s%s%s\n' "$bl" "$bar" "$br"
}

mode_one_liner() {
  local mode="$1"
  case "$mode" in
    safe|l1) echo "read-only sandbox + strict approvals" ;;
    cautious|l2) echo "workspace-write + strict approvals" ;;
    balanced|l3) echo "workspace-write + on-request approvals" ;;
    autonomous|l4) echo "workspace-write + on-failure approvals" ;;
    networked|l5) echo "workspace-write + on-failure approvals + network access" ;;
    full|l6) echo "danger-full-access + never ask for approval" ;;
    reckless|full-autonomy|l7) echo "bypass sandbox + bypass approvals (EXTREMELY DANGEROUS)" ;;
    *) echo "unknown" ;;
  esac
}

confirm_mode_if_needed() {
  local mode="$1"
  local subcommand="$2"
  local cmd_str="$3"
  local notify_text="${4:-}"

  [ "$CODEMAN_CONFIRM" = "1" ] || return 0
  [ -t 0 ] && [ -t 1 ] || return 0

  local severity="info"
  case "$mode" in
    networked|l5|full|l6) severity="warning" ;;
    reckless|full-autonomy|l7) severity="critical" ;;
  esac

  local status_line="‚úî Mode selected"
  case "$severity" in
    warning) status_line="‚ö† WARNING: high-risk mode selected" ;;
    critical) status_line="‚úñ DANGER: bypassing sandbox and approvals" ;;
  esac

  local -a cmd_lines
  mapfile -t cmd_lines < <(printf '%s\n' "$cmd_str" | fold -s -w 96)

  local -a lines
  lines+=("$status_line")
  lines+=("Mode: $mode")
  lines+=("About: $(mode_one_liner "$mode")")
  if [ "${#cmd_lines[@]}" -gt 0 ]; then
    lines+=("Codex: ${cmd_lines[0]}")
    local i
    for ((i = 1; i < ${#cmd_lines[@]}; i++)); do
      lines+=("      ${cmd_lines[$i]}")
    done
  fi
  [ -n "$notify_text" ] && lines+=("$notify_text")

  print_panel "$severity" "Codeman mode confirmation" "${lines[@]}" >&2
  printf '%s' "Press Enter to continue (Ctrl-C to abort): " >&2
  if [ -r /dev/tty ]; then
    IFS= read -r _ </dev/tty || exit 130
  else
    IFS= read -r _ || exit 130
  fi
}

load_saved_config() {
  if [ -f "$CONFIG_FILE" ]; then
    # shellcheck disable=SC1090
    . "$CONFIG_FILE"
  fi
}

default_host_label() {
  hostname -s 2>/dev/null || hostname 2>/dev/null || echo "unknown-host"
}

effective_notify_prefix() {
  if [ -n "${CODEMAN_NOTIFY_PREFIX:-}" ]; then
    printf '%s\n' "$CODEMAN_NOTIFY_PREFIX"
  elif [ -n "${CODEMAN_SAVED_NOTIFY_PREFIX:-}" ]; then
    printf '%s\n' "$CODEMAN_SAVED_NOTIFY_PREFIX"
  elif [ -n "${CODEMAN_NOTIFY_HOST_CODENAME:-}" ]; then
    printf '%s\n' "$CODEMAN_NOTIFY_HOST_CODENAME"
  else
    default_host_label
  fi
}

default_project_label() {
  local root
  root="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
  basename "$root"
}

effective_project_label() {
  if [ -n "${CODEMAN_NOTIFY_PROJECT_CODENAME:-}" ]; then
    printf '%s\n' "$CODEMAN_NOTIFY_PROJECT_CODENAME"
  else
    default_project_label
  fi
}

save_notify_prefix() {
  local value="$1"
  local tmp
  mkdir -p "$CONFIG_DIR"
  tmp="$(mktemp)"
  if [ -f "$CONFIG_FILE" ]; then
    awk '!/^CODEMAN_SAVED_NOTIFY_PREFIX=/' "$CONFIG_FILE" > "$tmp"
  else
    : > "$tmp"
  fi
  printf 'CODEMAN_SAVED_NOTIFY_PREFIX=%q\n' "$value" >> "$tmp"
  mv "$tmp" "$CONFIG_FILE"
}

clear_notify_prefix() {
  local tmp
  [ -f "$CONFIG_FILE" ] || return 0
  tmp="$(mktemp)"
  awk '!/^CODEMAN_SAVED_NOTIFY_PREFIX=/' "$CONFIG_FILE" > "$tmp"
  mv "$tmp" "$CONFIG_FILE"
}

print_help() {
  cat <<'EOF_HELP'
Codeman ü§ñüíªüî• ‚Äî Run Codex with explicit permission levels

USAGE
  codeman [--no-notify|-N] [--no-confirm|-y] [mode] [prompt_or_codex_args...]
  codeman [--no-notify|-N] [--no-confirm|-y] resume [mode] [resume_args...]
  codeman [--no-notify|-N] [--no-confirm|-y] fork [mode] [fork_args...]
  codeman version
  codeman upgrade
  codeman prefix [show|set <value>|clear]
  codeman notify-test
  codeman help | modes | aliases

LEVELS (most secure -> most risky)
  safe / l1                  üü¢ read-only sandbox + strict approvals
  cautious / l2              üü¢ workspace-write + strict approvals
  balanced / l3              üü° workspace-write + on-request approvals (default)
  autonomous / l4            üü° workspace-write + on-failure approvals
  networked / l5             üü† autonomous + network access
  full / l6                  üî¥ danger-full-access + no approvals
  reckless / l7              üö® bypass sandbox + bypass approvals
  full-autonomy              üö® alias of reckless (also accepts: "full autonomy")

HIGH-RISK WARNING üö®
  l6/l7 can run destructive commands, including deleting files.

WEBHOOK NOTIFICATIONS üîî
  Set CODEMAN_SLACK_WEBHOOK_URL and/or CODEMAN_DISCORD_WEBHOOK_URL.
  Triggered on:
  - wait/approval signals (sandbox denied, permission issues)
  - task completion

  Optional env:
  - CODEMAN_NOTIFY_PREFIX="HOST-CODENAME"
  - CODEMAN_NOTIFY_HOST_CODENAME="HOST-CODENAME"
  - CODEMAN_NOTIFY_PROJECT_CODENAME="PROJECT-CODENAME"
  - CODEMAN_NOTIFY_ON=wait,complete
  - CODEMAN_NOTIFY_COOLDOWN_SEC=30
  - CODEMAN_NOTIFY_DISABLED=1

  Runtime flags:
  - --no-notify, -N   Disable notifications even if webhook is configured
  - --no-confirm, -y  Skip the "press Enter to continue" confirmation

EXAMPLES
  codeman
  codeman -N l6
  codeman prefix set "MBP-Blue"
  codeman full autonomy "clean build artifacts"
  codeman resume l3 --last
  codeman resume l3 <session-uuid>
  codeman notify-test
  codeman version
  codeman upgrade
EOF_HELP
}

print_modes() {
  cat <<'EOF_MODES'
l1 safe          üü¢  -s read-only -a untrusted
l2 cautious      üü¢  -s workspace-write -a untrusted
l3 balanced      üü°  -s workspace-write -a on-request
l4 autonomous    üü°  -s workspace-write -a on-failure
l5 networked     üü†  l4 + -c sandbox_workspace_write.network_access=true
l6 full          üî¥  -s danger-full-access -a never
l7 reckless      üö®  --dangerously-bypass-approvals-and-sandbox
full-autonomy    üö®  alias of l7 ("full autonomy" works too)
EOF_MODES
}

print_mode_pick_hint() {
  local notify_text
  notify_text="$(print_notify_status)"

  cat <<'EOF_PICK'
Pick a mode explicitly.
Available modes:
EOF_PICK
  print_modes
  cat <<'EOF_PICK_EXAMPLES'

Examples:
  codeman l3
  codeman l6 "clean build artifacts"
  codeman resume l3 --last
EOF_PICK_EXAMPLES
  printf '\n%s\n' "$notify_text"
}

print_aliases() {
  cat <<'EOF_ALIASES'
# Codeman shortcuts (secure -> risky)
alias cdx1='codeman l1'
alias cdx2='codeman l2'
alias cdx3='codeman l3'
alias cdx4='codeman l4'
alias cdx5='codeman l5'
alias cdx6='codeman l6'
alias cdx7='codeman l7'

alias cdx-safe='codeman safe'
alias cdx='codeman balanced'
alias cdx-auto='codeman autonomous'
alias cdx-net='codeman networked'
alias cdx-full='codeman full'
alias cdx-reckless='codeman reckless'

alias cdx-r='codeman resume balanced --last'
alias cdx-rfull='codeman resume full --last'
alias cdx-f='codeman fork balanced --last'
alias cdx-ffull='codeman fork full --last'
alias cdx-v='codeman version'
alias cdx-quiet='codeman -N'
alias cdx-prefix='codeman prefix'
EOF_ALIASES
}

print_version() {
  local ver commit
  ver="$(read_version)"
  if command -v git >/dev/null 2>&1 && [ -d "$REPO_ROOT/.git" ]; then
    commit="$(git -C "$REPO_ROOT" rev-parse --short HEAD 2>/dev/null || true)"
  else
    commit=""
  fi

  if [ -n "$commit" ]; then
    printf 'codeman v%s (%s) ü§ñ\n' "$ver" "$commit"
  else
    printf 'codeman v%s ü§ñ\n' "$ver"
  fi
  printf 'home: %s\n' "$REPO_ROOT"
}

is_mode() {
  case "${1:-}" in
    safe|cautious|balanced|autonomous|networked|full|reckless|full-autonomy|l1|l2|l3|l4|l5|l6|l7)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

mode_flags() {
  local mode="${1:-balanced}"
  case "$mode" in
    safe|l1)
      printf '%s\n' -s read-only -a untrusted
      ;;
    cautious|l2)
      printf '%s\n' -s workspace-write -a untrusted
      ;;
    balanced|l3)
      printf '%s\n' -s workspace-write -a on-request
      ;;
    autonomous|l4)
      printf '%s\n' -s workspace-write -a on-failure
      ;;
    networked|l5)
      printf '%s\n' -s workspace-write -a on-failure -c sandbox_workspace_write.network_access=true
      ;;
    full|l6)
      printf '%s\n' -s danger-full-access -a never
      ;;
    reckless|full-autonomy|l7)
      printf '%s\n' --dangerously-bypass-approvals-and-sandbox
      ;;
    *)
      echo "Unknown mode: $mode" >&2
      exit 2
      ;;
  esac
}

event_enabled() {
  local event="$1"
  local configured="${CODEMAN_NOTIFY_ON:-wait,complete}"
  case ",$configured," in
    *",$event,"*) return 0 ;;
    *) return 1 ;;
  esac
}

notify_disabled() {
  if [ "$CODEMAN_NOTIFY_SUPPRESS" -eq 1 ]; then
    return 0
  fi
  if [ "${CODEMAN_NOTIFY_DISABLED:-0}" = "1" ]; then
    return 0
  fi
  return 1
}

has_webhook_config() {
  [ -n "${CODEMAN_SLACK_WEBHOOK_URL:-}" ] || [ -n "${CODEMAN_DISCORD_WEBHOOK_URL:-}" ]
}

notify_enabled() {
  has_webhook_config && ! notify_disabled && command -v curl >/dev/null 2>&1
}

print_notify_status() {
  if notify_enabled; then
    local targets=""
    [ -n "${CODEMAN_SLACK_WEBHOOK_URL:-}" ] && targets="Slack"
    if [ -n "${CODEMAN_DISCORD_WEBHOOK_URL:-}" ]; then
      if [ -n "$targets" ]; then
        targets="$targets+Discord"
      else
        targets="Discord"
      fi
    fi
    echo "üîî Notifications wired ($targets): notifications are ON."
    return 0
  fi

  if has_webhook_config; then
    if notify_disabled; then
      echo "üîï Webhook is configured, but notifications are disabled (--no-notify/-N or CODEMAN_NOTIFY_DISABLED=1)."
    else
      echo "‚ö†Ô∏è Webhook is configured, but notifications are unavailable (check curl)."
    fi
    return 0
  fi

  echo "‚ÑπÔ∏è No Slack/Discord integration configured. There won't be notifications."
}

send_notification_message() {
  local message="$1"
  local slack="${CODEMAN_SLACK_WEBHOOK_URL:-}"
  local discord="${CODEMAN_DISCORD_WEBHOOK_URL:-}"
  command -v curl >/dev/null 2>&1 || return 0

  local slack_payload discord_payload
  if command -v jq >/dev/null 2>&1; then
    slack_payload="$(jq -cn --arg text "$message" '{text:$text}')"
    discord_payload="$(jq -cn --arg content "$message" '{content:$content}')"
  else
    slack_payload="$(printf '{"text":"%s"}' "$(printf '%s' "$message" | sed 's/"/\\"/g')")"
    discord_payload="$(printf '{"content":"%s"}' "$(printf '%s' "$message" | sed 's/"/\\"/g')")"
  fi

  if [ -n "$slack" ]; then
    curl -fsS -m 8 -H 'Content-Type: application/json' -d "$slack_payload" "$slack" >/dev/null 2>&1 || true
  fi
  if [ -n "$discord" ]; then
    curl -fsS -m 8 -H 'Content-Type: application/json' -d "$discord_payload" "$discord" >/dev/null 2>&1 || true
  fi
}

notify_with_cooldown() {
  local kind="$1"
  local message="$2"
  local cooldown now last

  cooldown="${CODEMAN_NOTIFY_COOLDOWN_SEC:-30}"
  now="$(date +%s)"

  if [ "$kind" = "wait" ]; then
    last="$CODEMAN_NOTIFY_LAST_WAIT"
    if [ $((now - last)) -lt "$cooldown" ]; then
      return 0
    fi
    CODEMAN_NOTIFY_LAST_WAIT="$now"
  else
    last="$CODEMAN_NOTIFY_LAST_COMPLETE"
    if [ $((now - last)) -lt "$cooldown" ]; then
      return 0
    fi
    CODEMAN_NOTIFY_LAST_COMPLETE="$now"
  fi

  send_notification_message "$message"
}

latest_session_file() {
  ls -1t "$HOME"/.codex/sessions/*/*/*/*.jsonl 2>/dev/null | head -n 1 || true
}

handle_session_line() {
  local line="$1"
  local mode="$2"
  local prefix="$3"
  local project="$4"
  local line_type evt out

  command -v jq >/dev/null 2>&1 || return 0

  line_type="$(printf '%s\n' "$line" | jq -r '.type // empty' 2>/dev/null || true)"

  case "$line_type" in
    event_msg)
      evt="$(printf '%s\n' "$line" | jq -r '.payload.type // empty' 2>/dev/null || true)"
      if [ "$evt" = "task_complete" ] && event_enabled complete; then
        notify_with_cooldown complete "‚úÖ ${prefix} üìÅ ${project} üöÄ Codeman task complete (mode: ${mode})."
      fi
      ;;
    response_item)
      evt="$(printf '%s\n' "$line" | jq -r '.payload.type // empty' 2>/dev/null || true)"
      if [ "$evt" = "function_call_output" ] && event_enabled wait; then
        out="$(printf '%s\n' "$line" | jq -r '.payload.output // ""' 2>/dev/null || true)"
        if printf '%s' "$out" | grep -Eiq 'SandboxDenied|require_escalated|Operation not permitted|permission denied|ask for approval|request approval'; then
          notify_with_cooldown wait "üö® ${prefix} üìÅ ${project} ‚è≥ Codeman is waiting for your input/approval (mode: ${mode})."
        fi
      fi
      ;;
  esac
}

monitor_session_events() {
  local mode="$1"
  local stop_file="$2"
  local prefix="$3"
  local project="$4"
  local current_file=""
  local last_file=""
  local offset=0
  local total=0
  local new_lines line
  local poll

  poll="${CODEMAN_NOTIFY_POLL_SEC:-2}"
  current_file="$(latest_session_file)"
  if [ -n "$current_file" ] && [ -f "$current_file" ]; then
    last_file="$current_file"
    offset="$(wc -l < "$current_file" | tr -d ' ')"
  fi

  while [ ! -f "$stop_file" ]; do
    current_file="$(latest_session_file)"

    if [ -n "$current_file" ] && [ -f "$current_file" ]; then
      if [ "$current_file" != "$last_file" ]; then
        last_file="$current_file"
        offset=0
      fi

      total="$(wc -l < "$current_file" | tr -d ' ')"
      if [ "$total" -gt "$offset" ]; then
        new_lines="$(sed -n "$((offset + 1)),$total p" "$current_file")"
        while IFS= read -r line; do
          [ -n "$line" ] || continue
          handle_session_line "$line" "$mode" "$prefix" "$project"
        done <<EOF_LINES
$new_lines
EOF_LINES
        offset="$total"
      fi
    fi

    sleep "$poll"
  done
}

run_prefix_command() {
  local action="${1:-show}"
  shift || true
  case "$action" in
    show)
      echo "prefix: $(effective_notify_prefix)"
      ;;
    set)
      if [ "$#" -lt 1 ]; then
        echo "Usage: codeman prefix set <value>" >&2
        exit 2
      fi
      save_notify_prefix "$*"
      echo "Saved prefix: $*"
      ;;
    clear)
      clear_notify_prefix
      unset CODEMAN_SAVED_NOTIFY_PREFIX
      echo "Cleared saved prefix. Effective prefix: $(effective_notify_prefix)"
      ;;
    help|-h|--help)
      cat <<'EOF_PREFIX'
Usage:
  codeman prefix
  codeman prefix show
  codeman prefix set <value>
  codeman prefix clear
EOF_PREFIX
      ;;
    *)
      echo "Unknown prefix action: $action" >&2
      exit 2
      ;;
  esac
}

run_notify_test() {
  local prefix project
  prefix="$(effective_notify_prefix)"
  project="$(effective_project_label)"

  if ! has_webhook_config; then
    echo "‚ÑπÔ∏è No Slack/Discord integration configured. There won't be notifications." >&2
    exit 1
  fi
  if notify_disabled; then
    echo "üîï Webhook is configured, but notifications are disabled (--no-notify/-N or CODEMAN_NOTIFY_DISABLED=1)."
    exit 0
  fi
  send_notification_message "üß™ ${prefix} üìÅ ${project} ‚úÖ Codeman notification test."
  echo "Webhook notification test sent (if webhook URL is valid)."
}

run_upgrade() {
  if ! command -v git >/dev/null 2>&1; then
    echo "üö® git is required for codeman upgrade" >&2
    exit 1
  fi
  if [ ! -d "$REPO_ROOT/.git" ]; then
    echo "üö® upgrade expects a git checkout at: $REPO_ROOT" >&2
    exit 1
  fi
  if ! git -C "$REPO_ROOT" remote get-url origin >/dev/null 2>&1; then
    echo "üö® No origin remote configured. Add it, then rerun: codeman upgrade" >&2
    exit 1
  fi

  local branch
  branch="$(git -C "$REPO_ROOT" rev-parse --abbrev-ref HEAD 2>/dev/null || echo main)"

  echo "üöÄ Upgrading Codeman on branch '$branch' from origin..."
  git -C "$REPO_ROOT" fetch --prune origin
  git -C "$REPO_ROOT" pull --ff-only origin "$branch"

  if [ -x "$REPO_ROOT/install.sh" ]; then
    "$REPO_ROOT/install.sh" --local --bin-dir "${CODEMAN_BIN_DIR:-$HOME/bin}" --zshrc "${CODEMAN_ZSHRC:-$HOME/.zshrc}" >/dev/null
  fi

  echo "‚úÖ Upgrade complete: codeman v$(read_version)"
}

run_codex() {
  local subcommand="$1"
  shift
  local mode="${1:-balanced}"
  local explicit_mode=0
  local stop_file monitor_pid rc
  local project prefix

  if [ "$mode" = "full" ] && { [ "${2:-}" = "autonomy" ] || [ "${2:-}" = "auto" ]; }; then
    mode="full-autonomy"
    explicit_mode=1
    shift 2
  fi

  if is_mode "$mode"; then
    explicit_mode=1
    shift
  else
    mode="balanced"
  fi

  mapfile -t flags < <(mode_flags "$mode")

  local notify_text
  notify_text="$(print_notify_status)"

  local will_confirm=0
  if [ "$explicit_mode" -eq 1 ] && [ -z "$subcommand" ] && [ "$CODEMAN_CONFIRM" = "1" ] && [ -t 0 ] && [ -t 1 ]; then
    will_confirm=1
  fi

  if [ "$explicit_mode" -eq 1 ] && [ -z "$subcommand" ]; then
    local cmd_str
    local -a cmd
    cmd=(codex)
    [ -n "$subcommand" ] && cmd+=("$subcommand")
    cmd+=("${flags[@]}")
    cmd+=("$@")
    cmd_str="$(printf '%q ' "${cmd[@]}")"
    cmd_str="${cmd_str% }"
    if [ "$will_confirm" -eq 1 ]; then
      confirm_mode_if_needed "$mode" "$subcommand" "$cmd_str" "$notify_text"
    fi
  fi

  if [ "$will_confirm" -eq 0 ]; then
    printf '%s\n' "$notify_text"
  fi

  if notify_enabled; then
    prefix="$(effective_notify_prefix)"
    project="$(effective_project_label)"
    stop_file="$(mktemp /tmp/codeman-notify-stop.XXXXXX)"
    monitor_session_events "$mode" "$stop_file" "$prefix" "$project" &
    monitor_pid=$!

    set +e
    if [ -z "$subcommand" ]; then
      codex "${flags[@]}" "$@"
      rc=$?
    else
      codex "$subcommand" "${flags[@]}" "$@"
      rc=$?
    fi
    set -e

    : > "$stop_file"
    wait "$monitor_pid" 2>/dev/null || true
    rm -f "$stop_file"
    return "$rc"
  fi

  if [ -z "$subcommand" ]; then
    exec codex "${flags[@]}" "$@"
  fi
  exec codex "$subcommand" "${flags[@]}" "$@"
}

load_saved_config

PARSED_ARGS=()
while [ "$#" -gt 0 ]; do
  case "$1" in
    --no-notify|-N)
      CODEMAN_NOTIFY_SUPPRESS=1
      shift
      ;;
    --no-confirm|-y)
      CODEMAN_CONFIRM=0
      shift
      ;;
    --)
      shift
      while [ "$#" -gt 0 ]; do
        PARSED_ARGS+=("$1")
        shift
      done
      ;;
    *)
      PARSED_ARGS+=("$1")
      shift
      ;;
  esac
done
set -- "${PARSED_ARGS[@]}"

cmd="${1:-}"
case "$cmd" in
  "")
    print_mode_pick_hint
    exit 2
    ;;
  menu)
    print_mode_pick_hint
    exit 2
    ;;
  help|-h|--help)
    print_help
    ;;
  modes)
    print_modes
    ;;
  aliases)
    print_aliases
    ;;
  version|-V|--version)
    print_version
    ;;
  prefix)
    shift
    run_prefix_command "$@"
    ;;
  notify-test)
    run_notify_test
    ;;
  upgrade)
    run_upgrade
    ;;
  resume|fork)
    shift
    run_codex "$cmd" "$@"
    ;;
  safe|cautious|balanced|autonomous|networked|full|reckless|full-autonomy|l1|l2|l3|l4|l5|l6|l7)
    run_codex "" "$@"
    ;;
  *)
    run_codex "" "$@"
    ;;
esac
