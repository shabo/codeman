#!/usr/bin/env bash
set -euo pipefail

resolve_source_path() {
  local src="$1"
  while [ -L "$src" ]; do
    local dir
    dir="$(cd -- "$(dirname -- "$src")" && pwd)"
    src="$(readlink "$src")"
    case "$src" in
      /*) ;;
      *) src="$dir/$src" ;;
    esac
  done
  local final_dir
  final_dir="$(cd -- "$(dirname -- "$src")" && pwd)"
  printf '%s/%s\n' "$final_dir" "$(basename -- "$src")"
}

SCRIPT_PATH="$(resolve_source_path "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname -- "$SCRIPT_PATH")"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"
VERSION_FILE="$REPO_ROOT/VERSION"
CONFIG_DIR="${CODEMAN_CONFIG_DIR:-$HOME/.config/codeman}"
CONFIG_FILE="$CONFIG_DIR/config.env"

CODEMAN_NOTIFY_LAST_WAIT=0
CODEMAN_NOTIFY_LAST_COMPLETE=0
CODEMAN_NOTIFY_SUPPRESS=0
CODEMAN_SAVED_NOTIFY_PREFIX="${CODEMAN_SAVED_NOTIFY_PREFIX:-}"

read_version() {
  if [ -f "$VERSION_FILE" ]; then
    tr -d '[:space:]' < "$VERSION_FILE"
  else
    printf '0.0.0-unknown'
  fi
}

load_saved_config() {
  if [ -f "$CONFIG_FILE" ]; then
    # shellcheck disable=SC1090
    . "$CONFIG_FILE"
  fi
}

default_host_label() {
  hostname -s 2>/dev/null || hostname 2>/dev/null || echo "unknown-host"
}

effective_notify_prefix() {
  if [ -n "${CODEMAN_NOTIFY_PREFIX:-}" ]; then
    printf '%s\n' "$CODEMAN_NOTIFY_PREFIX"
  elif [ -n "${CODEMAN_SAVED_NOTIFY_PREFIX:-}" ]; then
    printf '%s\n' "$CODEMAN_SAVED_NOTIFY_PREFIX"
  elif [ -n "${CODEMAN_NOTIFY_HOST_CODENAME:-}" ]; then
    printf '%s\n' "$CODEMAN_NOTIFY_HOST_CODENAME"
  else
    default_host_label
  fi
}

default_project_label() {
  local root
  root="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
  basename "$root"
}

effective_project_label() {
  if [ -n "${CODEMAN_NOTIFY_PROJECT_CODENAME:-}" ]; then
    printf '%s\n' "$CODEMAN_NOTIFY_PROJECT_CODENAME"
  else
    default_project_label
  fi
}

save_notify_prefix() {
  local value="$1"
  local tmp
  mkdir -p "$CONFIG_DIR"
  tmp="$(mktemp)"
  if [ -f "$CONFIG_FILE" ]; then
    awk '!/^CODEMAN_SAVED_NOTIFY_PREFIX=/' "$CONFIG_FILE" > "$tmp"
  else
    : > "$tmp"
  fi
  printf 'CODEMAN_SAVED_NOTIFY_PREFIX=%q\n' "$value" >> "$tmp"
  mv "$tmp" "$CONFIG_FILE"
}

clear_notify_prefix() {
  local tmp
  [ -f "$CONFIG_FILE" ] || return 0
  tmp="$(mktemp)"
  awk '!/^CODEMAN_SAVED_NOTIFY_PREFIX=/' "$CONFIG_FILE" > "$tmp"
  mv "$tmp" "$CONFIG_FILE"
}

print_help() {
  cat <<'EOF_HELP'
Codeman ü§ñüíªüî• ‚Äî Run Codex with explicit permission levels

USAGE
  codeman [--no-notify|-N] [mode] [prompt_or_codex_args...]
  codeman [--no-notify|-N] menu
  codeman [--no-notify|-N] resume [mode] [resume_args...]
  codeman [--no-notify|-N] fork [mode] [fork_args...]
  codeman version
  codeman upgrade
  codeman prefix [show|set <value>|clear]
  codeman notify-test
  codeman help | modes | aliases

LEVELS (most secure -> most risky)
  safe / l1                  üü¢ read-only sandbox + strict approvals
  cautious / l2              üü¢ workspace-write + strict approvals
  balanced / l3              üü° workspace-write + on-request approvals (default)
  autonomous / l4            üü° workspace-write + on-failure approvals
  networked / l5             üü† autonomous + network access
  full / l6                  üî¥ danger-full-access + no approvals
  reckless / l7              üö® bypass sandbox + bypass approvals
  full-autonomy              üö® alias of reckless (also accepts: "full autonomy")

HIGH-RISK WARNING üö®
  l6/l7 can run destructive commands, including deleting files.

INTERACTIVE MODE
  Running `codeman` with no args opens mode picker.
  - with fzf: arrow keys + Enter
  - without fzf: type mode name (l1..l7 or alias)

WEBHOOK NOTIFICATIONS üîî
  Set CODEMAN_SLACK_WEBHOOK_URL and/or CODEMAN_DISCORD_WEBHOOK_URL.
  Triggered on:
  - wait/approval signals (sandbox denied, permission issues)
  - task completion

  Optional env:
  - CODEMAN_NOTIFY_PREFIX="HOST-CODENAME"
  - CODEMAN_NOTIFY_HOST_CODENAME="HOST-CODENAME"
  - CODEMAN_NOTIFY_PROJECT_CODENAME="PROJECT-CODENAME"
  - CODEMAN_NOTIFY_ON=wait,complete
  - CODEMAN_NOTIFY_COOLDOWN_SEC=30
  - CODEMAN_NOTIFY_DISABLED=1

  Runtime flags:
  - --no-notify, -N   Disable notifications even if webhook is configured

EXAMPLES
  codeman
  codeman -N l6
  codeman prefix set "MBP-Blue"
  codeman full autonomy "clean build artifacts"
  codeman resume l3 --last
  codeman notify-test
  codeman version
  codeman upgrade
EOF_HELP
}

print_modes() {
  cat <<'EOF_MODES'
l1 safe          üü¢  -s read-only -a untrusted
l2 cautious      üü¢  -s workspace-write -a untrusted
l3 balanced      üü°  -s workspace-write -a on-request
l4 autonomous    üü°  -s workspace-write -a on-failure
l5 networked     üü†  l4 + -c sandbox_workspace_write.network_access=true
l6 full          üî¥  -s danger-full-access -a never
l7 reckless      üö®  --dangerously-bypass-approvals-and-sandbox
full-autonomy    üö®  alias of l7 ("full autonomy" works too)
EOF_MODES
}

print_aliases() {
  cat <<'EOF_ALIASES'
# Codeman shortcuts (secure -> risky)
alias cdx1='codeman l1'
alias cdx2='codeman l2'
alias cdx3='codeman l3'
alias cdx4='codeman l4'
alias cdx5='codeman l5'
alias cdx6='codeman l6'
alias cdx7='codeman l7'

alias cdx-safe='codeman safe'
alias cdx='codeman balanced'
alias cdx-auto='codeman autonomous'
alias cdx-net='codeman networked'
alias cdx-full='codeman full'
alias cdx-reckless='codeman reckless'

alias cdx-r='codeman resume balanced --last'
alias cdx-rfull='codeman resume full --last'
alias cdx-f='codeman fork balanced --last'
alias cdx-ffull='codeman fork full --last'
alias cdx-v='codeman version'
alias cdx-menu='codeman menu'
alias cdx-quiet='codeman -N'
alias cdx-prefix='codeman prefix'
EOF_ALIASES
}

print_version() {
  local ver commit
  ver="$(read_version)"
  if command -v git >/dev/null 2>&1 && [ -d "$REPO_ROOT/.git" ]; then
    commit="$(git -C "$REPO_ROOT" rev-parse --short HEAD 2>/dev/null || true)"
  else
    commit=""
  fi

  if [ -n "$commit" ]; then
    printf 'codeman v%s (%s) ü§ñ\n' "$ver" "$commit"
  else
    printf 'codeman v%s ü§ñ\n' "$ver"
  fi
  printf 'home: %s\n' "$REPO_ROOT"
}

is_mode() {
  case "${1:-}" in
    safe|cautious|balanced|autonomous|networked|full|reckless|full-autonomy|l1|l2|l3|l4|l5|l6|l7)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

mode_flags() {
  local mode="${1:-balanced}"
  case "$mode" in
    safe|l1)
      printf '%s\n' -s read-only -a untrusted
      ;;
    cautious|l2)
      printf '%s\n' -s workspace-write -a untrusted
      ;;
    balanced|l3)
      printf '%s\n' -s workspace-write -a on-request
      ;;
    autonomous|l4)
      printf '%s\n' -s workspace-write -a on-failure
      ;;
    networked|l5)
      printf '%s\n' -s workspace-write -a on-failure -c sandbox_workspace_write.network_access=true
      ;;
    full|l6)
      printf '%s\n' -s danger-full-access -a never
      ;;
    reckless|full-autonomy|l7)
      printf '%s\n' --dangerously-bypass-approvals-and-sandbox
      ;;
    *)
      echo "Unknown mode: $mode" >&2
      exit 2
      ;;
  esac
}

event_enabled() {
  local event="$1"
  local configured="${CODEMAN_NOTIFY_ON:-wait,complete}"
  case ",$configured," in
    *",$event,"*) return 0 ;;
    *) return 1 ;;
  esac
}

notify_disabled() {
  if [ "$CODEMAN_NOTIFY_SUPPRESS" -eq 1 ]; then
    return 0
  fi
  if [ "${CODEMAN_NOTIFY_DISABLED:-0}" = "1" ]; then
    return 0
  fi
  return 1
}

has_webhook_config() {
  [ -n "${CODEMAN_SLACK_WEBHOOK_URL:-}" ] || [ -n "${CODEMAN_DISCORD_WEBHOOK_URL:-}" ]
}

notify_enabled() {
  has_webhook_config && ! notify_disabled && command -v curl >/dev/null 2>&1
}

print_notify_status() {
  if notify_enabled; then
    local targets=""
    [ -n "${CODEMAN_SLACK_WEBHOOK_URL:-}" ] && targets="Slack"
    if [ -n "${CODEMAN_DISCORD_WEBHOOK_URL:-}" ]; then
      if [ -n "$targets" ]; then
        targets="$targets+Discord"
      else
        targets="Discord"
      fi
    fi
    echo "üîî Notifications wired ($targets): notifications are ON."
    return 0
  fi

  if has_webhook_config; then
    if notify_disabled; then
      echo "üîï Webhook is configured, but notifications are disabled (--no-notify/-N or CODEMAN_NOTIFY_DISABLED=1)."
    else
      echo "‚ö†Ô∏è Webhook is configured, but notifications are unavailable (check curl)."
    fi
    return 0
  fi

  echo "‚ÑπÔ∏è No Slack/Discord integration configured. There won't be notifications."
}

send_notification_message() {
  local message="$1"
  local slack="${CODEMAN_SLACK_WEBHOOK_URL:-}"
  local discord="${CODEMAN_DISCORD_WEBHOOK_URL:-}"
  command -v curl >/dev/null 2>&1 || return 0

  local slack_payload discord_payload
  if command -v jq >/dev/null 2>&1; then
    slack_payload="$(jq -cn --arg text "$message" '{text:$text}')"
    discord_payload="$(jq -cn --arg content "$message" '{content:$content}')"
  else
    slack_payload="$(printf '{"text":"%s"}' "$(printf '%s' "$message" | sed 's/"/\\"/g')")"
    discord_payload="$(printf '{"content":"%s"}' "$(printf '%s' "$message" | sed 's/"/\\"/g')")"
  fi

  if [ -n "$slack" ]; then
    curl -fsS -m 8 -H 'Content-Type: application/json' -d "$slack_payload" "$slack" >/dev/null 2>&1 || true
  fi
  if [ -n "$discord" ]; then
    curl -fsS -m 8 -H 'Content-Type: application/json' -d "$discord_payload" "$discord" >/dev/null 2>&1 || true
  fi
}

notify_with_cooldown() {
  local kind="$1"
  local message="$2"
  local cooldown now last

  cooldown="${CODEMAN_NOTIFY_COOLDOWN_SEC:-30}"
  now="$(date +%s)"

  if [ "$kind" = "wait" ]; then
    last="$CODEMAN_NOTIFY_LAST_WAIT"
    if [ $((now - last)) -lt "$cooldown" ]; then
      return 0
    fi
    CODEMAN_NOTIFY_LAST_WAIT="$now"
  else
    last="$CODEMAN_NOTIFY_LAST_COMPLETE"
    if [ $((now - last)) -lt "$cooldown" ]; then
      return 0
    fi
    CODEMAN_NOTIFY_LAST_COMPLETE="$now"
  fi

  send_notification_message "$message"
}

latest_session_file() {
  ls -1t "$HOME"/.codex/sessions/*/*/*/*.jsonl 2>/dev/null | head -n 1 || true
}

handle_session_line() {
  local line="$1"
  local mode="$2"
  local prefix="$3"
  local project="$4"
  local line_type evt out

  command -v jq >/dev/null 2>&1 || return 0

  line_type="$(printf '%s\n' "$line" | jq -r '.type // empty' 2>/dev/null || true)"

  case "$line_type" in
    event_msg)
      evt="$(printf '%s\n' "$line" | jq -r '.payload.type // empty' 2>/dev/null || true)"
      if [ "$evt" = "task_complete" ] && event_enabled complete; then
        notify_with_cooldown complete "‚úÖ ${prefix} üìÅ ${project} üöÄ Codeman task complete (mode: ${mode})."
      fi
      ;;
    response_item)
      evt="$(printf '%s\n' "$line" | jq -r '.payload.type // empty' 2>/dev/null || true)"
      if [ "$evt" = "function_call_output" ] && event_enabled wait; then
        out="$(printf '%s\n' "$line" | jq -r '.payload.output // ""' 2>/dev/null || true)"
        if printf '%s' "$out" | grep -Eiq 'SandboxDenied|require_escalated|Operation not permitted|permission denied|ask for approval|request approval'; then
          notify_with_cooldown wait "üö® ${prefix} üìÅ ${project} ‚è≥ Codeman is waiting for your input/approval (mode: ${mode})."
        fi
      fi
      ;;
  esac
}

monitor_session_events() {
  local mode="$1"
  local stop_file="$2"
  local prefix="$3"
  local project="$4"
  local current_file=""
  local last_file=""
  local offset=0
  local total=0
  local new_lines line
  local poll

  poll="${CODEMAN_NOTIFY_POLL_SEC:-2}"
  current_file="$(latest_session_file)"
  if [ -n "$current_file" ] && [ -f "$current_file" ]; then
    last_file="$current_file"
    offset="$(wc -l < "$current_file" | tr -d ' ')"
  fi

  while [ ! -f "$stop_file" ]; do
    current_file="$(latest_session_file)"

    if [ -n "$current_file" ] && [ -f "$current_file" ]; then
      if [ "$current_file" != "$last_file" ]; then
        last_file="$current_file"
        offset=0
      fi

      total="$(wc -l < "$current_file" | tr -d ' ')"
      if [ "$total" -gt "$offset" ]; then
        new_lines="$(sed -n "$((offset + 1)),$total p" "$current_file")"
        while IFS= read -r line; do
          [ -n "$line" ] || continue
          handle_session_line "$line" "$mode" "$prefix" "$project"
        done <<EOF_LINES
$new_lines
EOF_LINES
        offset="$total"
      fi
    fi

    sleep "$poll"
  done
}

prompt_mode_menu() {
  local choice mode

  if command -v fzf >/dev/null 2>&1; then
    choice="$(cat <<'EOF_CHOICES' | fzf --height=70% --reverse --prompt='Codeman mode > ' --header='Use ‚Üë‚Üì and Enter (Esc to cancel)'
l1  safe        üü¢ read-only + strict approvals
l2  cautious    üü¢ workspace-write + strict approvals
l3  balanced    üü° workspace-write + on-request approvals (default)
l4  autonomous  üü° workspace-write + on-failure approvals
l5  networked   üü† autonomous + network access
l6  full        üî¥ danger-full-access + no approvals
l7  reckless    üö® bypass sandbox + bypass approvals
EOF_CHOICES
)" || return 1
    mode="$(printf '%s' "$choice" | awk '{print $1}')"
    [ -n "$mode" ] || return 1
    printf '%s\n' "$mode"
    return 0
  fi

  echo "Select Codeman mode (or press Enter for l3/balanced):"
  print_modes
  printf '\nMode: '
  read -r mode || return 1
  mode="${mode:-l3}"
  printf '%s\n' "$mode"
}

run_prefix_command() {
  local action="${1:-show}"
  shift || true
  case "$action" in
    show)
      echo "prefix: $(effective_notify_prefix)"
      ;;
    set)
      if [ "$#" -lt 1 ]; then
        echo "Usage: codeman prefix set <value>" >&2
        exit 2
      fi
      save_notify_prefix "$*"
      echo "Saved prefix: $*"
      ;;
    clear)
      clear_notify_prefix
      unset CODEMAN_SAVED_NOTIFY_PREFIX
      echo "Cleared saved prefix. Effective prefix: $(effective_notify_prefix)"
      ;;
    help|-h|--help)
      cat <<'EOF_PREFIX'
Usage:
  codeman prefix
  codeman prefix show
  codeman prefix set <value>
  codeman prefix clear
EOF_PREFIX
      ;;
    *)
      echo "Unknown prefix action: $action" >&2
      exit 2
      ;;
  esac
}

run_notify_test() {
  local prefix project
  prefix="$(effective_notify_prefix)"
  project="$(effective_project_label)"

  if ! has_webhook_config; then
    echo "‚ÑπÔ∏è No Slack/Discord integration configured. There won't be notifications." >&2
    exit 1
  fi
  if notify_disabled; then
    echo "üîï Webhook is configured, but notifications are disabled (--no-notify/-N or CODEMAN_NOTIFY_DISABLED=1)."
    exit 0
  fi
  send_notification_message "üß™ ${prefix} üìÅ ${project} ‚úÖ Codeman notification test."
  echo "Webhook notification test sent (if webhook URL is valid)."
}

run_upgrade() {
  if ! command -v git >/dev/null 2>&1; then
    echo "üö® git is required for codeman upgrade" >&2
    exit 1
  fi
  if [ ! -d "$REPO_ROOT/.git" ]; then
    echo "üö® upgrade expects a git checkout at: $REPO_ROOT" >&2
    exit 1
  fi
  if ! git -C "$REPO_ROOT" remote get-url origin >/dev/null 2>&1; then
    echo "üö® No origin remote configured. Add it, then rerun: codeman upgrade" >&2
    exit 1
  fi

  local branch
  branch="$(git -C "$REPO_ROOT" rev-parse --abbrev-ref HEAD 2>/dev/null || echo main)"

  echo "üöÄ Upgrading Codeman on branch '$branch' from origin..."
  git -C "$REPO_ROOT" fetch --prune origin
  git -C "$REPO_ROOT" pull --ff-only origin "$branch"

  if [ -x "$REPO_ROOT/install.sh" ]; then
    "$REPO_ROOT/install.sh" --local --bin-dir "${CODEMAN_BIN_DIR:-$HOME/bin}" --zshrc "${CODEMAN_ZSHRC:-$HOME/.zshrc}" >/dev/null
  fi

  echo "‚úÖ Upgrade complete: codeman v$(read_version)"
}

run_codex() {
  local subcommand="$1"
  shift
  local mode="${1:-balanced}"
  local stop_file monitor_pid rc
  local project prefix

  if [ "$mode" = "full" ] && { [ "${2:-}" = "autonomy" ] || [ "${2:-}" = "auto" ]; }; then
    mode="full-autonomy"
    shift 2
  fi

  if is_mode "$mode"; then
    shift
  else
    mode="balanced"
  fi

  mapfile -t flags < <(mode_flags "$mode")

  print_notify_status

  if notify_enabled; then
    prefix="$(effective_notify_prefix)"
    project="$(effective_project_label)"
    stop_file="$(mktemp /tmp/codeman-notify-stop.XXXXXX)"
    monitor_session_events "$mode" "$stop_file" "$prefix" "$project" &
    monitor_pid=$!

    set +e
    if [ -z "$subcommand" ]; then
      codex "${flags[@]}" "$@"
      rc=$?
    else
      codex "$subcommand" "${flags[@]}" "$@"
      rc=$?
    fi
    set -e

    : > "$stop_file"
    wait "$monitor_pid" 2>/dev/null || true
    rm -f "$stop_file"
    return "$rc"
  fi

  if [ -z "$subcommand" ]; then
    exec codex "${flags[@]}" "$@"
  fi
  exec codex "$subcommand" "${flags[@]}" "$@"
}

load_saved_config

PARSED_ARGS=()
while [ "$#" -gt 0 ]; do
  case "$1" in
    --no-notify|-N)
      CODEMAN_NOTIFY_SUPPRESS=1
      shift
      ;;
    --)
      shift
      while [ "$#" -gt 0 ]; do
        PARSED_ARGS+=("$1")
        shift
      done
      ;;
    *)
      PARSED_ARGS+=("$1")
      shift
      ;;
  esac
done
set -- "${PARSED_ARGS[@]}"

cmd="${1:-}"
case "$cmd" in
  "")
    if [ -t 0 ] && [ -t 1 ]; then
      selected_mode="$(prompt_mode_menu)" || exit 130
      run_codex "" "$selected_mode"
    else
      run_codex ""
    fi
    ;;
  menu)
    selected_mode="$(prompt_mode_menu)" || exit 130
    run_codex "" "$selected_mode"
    ;;
  help|-h|--help)
    print_help
    ;;
  modes)
    print_modes
    ;;
  aliases)
    print_aliases
    ;;
  version|-V|--version)
    print_version
    ;;
  prefix)
    shift
    run_prefix_command "$@"
    ;;
  notify-test)
    run_notify_test
    ;;
  upgrade)
    run_upgrade
    ;;
  resume|fork)
    shift
    run_codex "$cmd" "$@"
    ;;
  safe|cautious|balanced|autonomous|networked|full|reckless|full-autonomy|l1|l2|l3|l4|l5|l6|l7)
    run_codex "" "$@"
    ;;
  *)
    run_codex "" "$@"
    ;;
esac
